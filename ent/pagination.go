// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/gen0cide/laforge/ent/adhocplan"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    uuid.UUID `msgpack:"i"`
	Value Value     `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// AdhocPlanEdge is the edge representation of AdhocPlan.
type AdhocPlanEdge struct {
	Node   *AdhocPlan `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// AdhocPlanConnection is the connection containing edges to AdhocPlan.
type AdhocPlanConnection struct {
	Edges      []*AdhocPlanEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// AdhocPlanPaginateOption enables pagination customization.
type AdhocPlanPaginateOption func(*adhocPlanPager) error

// WithAdhocPlanOrder configures pagination ordering.
func WithAdhocPlanOrder(order *AdhocPlanOrder) AdhocPlanPaginateOption {
	if order == nil {
		order = DefaultAdhocPlanOrder
	}
	o := *order
	return func(pager *adhocPlanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAdhocPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAdhocPlanFilter configures pagination filter.
func WithAdhocPlanFilter(filter func(*AdhocPlanQuery) (*AdhocPlanQuery, error)) AdhocPlanPaginateOption {
	return func(pager *adhocPlanPager) error {
		if filter == nil {
			return errors.New("AdhocPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type adhocPlanPager struct {
	order  *AdhocPlanOrder
	filter func(*AdhocPlanQuery) (*AdhocPlanQuery, error)
}

func newAdhocPlanPager(opts []AdhocPlanPaginateOption) (*adhocPlanPager, error) {
	pager := &adhocPlanPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAdhocPlanOrder
	}
	return pager, nil
}

func (p *adhocPlanPager) applyFilter(query *AdhocPlanQuery) (*AdhocPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *adhocPlanPager) toCursor(ap *AdhocPlan) Cursor {
	return p.order.Field.toCursor(ap)
}

func (p *adhocPlanPager) applyCursors(query *AdhocPlanQuery, after, before *Cursor) *AdhocPlanQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAdhocPlanOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *adhocPlanPager) applyOrder(query *AdhocPlanQuery, reverse bool) *AdhocPlanQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAdhocPlanOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAdhocPlanOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AdhocPlan.
func (ap *AdhocPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AdhocPlanPaginateOption,
) (*AdhocPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAdhocPlanPager(opts)
	if err != nil {
		return nil, err
	}

	if ap, err = pager.applyFilter(ap); err != nil {
		return nil, err
	}

	conn := &AdhocPlanConnection{Edges: []*AdhocPlanEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ap.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ap.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ap = pager.applyCursors(ap, after, before)
	ap = pager.applyOrder(ap, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ap = ap.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ap = ap.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ap.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AdhocPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AdhocPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AdhocPlan {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AdhocPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AdhocPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AdhocPlanOrderField defines the ordering field of AdhocPlan.
type AdhocPlanOrderField struct {
	field    string
	toCursor func(*AdhocPlan) Cursor
}

// AdhocPlanOrder defines the ordering of AdhocPlan.
type AdhocPlanOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *AdhocPlanOrderField `json:"field"`
}

// DefaultAdhocPlanOrder is the default ordering of AdhocPlan.
var DefaultAdhocPlanOrder = &AdhocPlanOrder{
	Direction: OrderDirectionAsc,
	Field: &AdhocPlanOrderField{
		field: adhocplan.FieldID,
		toCursor: func(ap *AdhocPlan) Cursor {
			return Cursor{ID: ap.ID}
		},
	},
}

// ToEdge converts AdhocPlan into AdhocPlanEdge.
func (ap *AdhocPlan) ToEdge(order *AdhocPlanOrder) *AdhocPlanEdge {
	if order == nil {
		order = DefaultAdhocPlanOrder
	}
	return &AdhocPlanEdge{
		Node:   ap,
		Cursor: order.Field.toCursor(ap),
	}
}

// AgentStatusEdge is the edge representation of AgentStatus.
type AgentStatusEdge struct {
	Node   *AgentStatus `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AgentStatusConnection is the connection containing edges to AgentStatus.
type AgentStatusConnection struct {
	Edges      []*AgentStatusEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// AgentStatusPaginateOption enables pagination customization.
type AgentStatusPaginateOption func(*agentStatusPager) error

// WithAgentStatusOrder configures pagination ordering.
func WithAgentStatusOrder(order *AgentStatusOrder) AgentStatusPaginateOption {
	if order == nil {
		order = DefaultAgentStatusOrder
	}
	o := *order
	return func(pager *agentStatusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAgentStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAgentStatusFilter configures pagination filter.
func WithAgentStatusFilter(filter func(*AgentStatusQuery) (*AgentStatusQuery, error)) AgentStatusPaginateOption {
	return func(pager *agentStatusPager) error {
		if filter == nil {
			return errors.New("AgentStatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type agentStatusPager struct {
	order  *AgentStatusOrder
	filter func(*AgentStatusQuery) (*AgentStatusQuery, error)
}

func newAgentStatusPager(opts []AgentStatusPaginateOption) (*agentStatusPager, error) {
	pager := &agentStatusPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAgentStatusOrder
	}
	return pager, nil
}

func (p *agentStatusPager) applyFilter(query *AgentStatusQuery) (*AgentStatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *agentStatusPager) toCursor(as *AgentStatus) Cursor {
	return p.order.Field.toCursor(as)
}

func (p *agentStatusPager) applyCursors(query *AgentStatusQuery, after, before *Cursor) *AgentStatusQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAgentStatusOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *agentStatusPager) applyOrder(query *AgentStatusQuery, reverse bool) *AgentStatusQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAgentStatusOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAgentStatusOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AgentStatus.
func (as *AgentStatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AgentStatusPaginateOption,
) (*AgentStatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAgentStatusPager(opts)
	if err != nil {
		return nil, err
	}

	if as, err = pager.applyFilter(as); err != nil {
		return nil, err
	}

	conn := &AgentStatusConnection{Edges: []*AgentStatusEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := as.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := as.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	as = pager.applyCursors(as, after, before)
	as = pager.applyOrder(as, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		as = as.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		as = as.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := as.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AgentStatus
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AgentStatus {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AgentStatus {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AgentStatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AgentStatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AgentStatusOrderField defines the ordering field of AgentStatus.
type AgentStatusOrderField struct {
	field    string
	toCursor func(*AgentStatus) Cursor
}

// AgentStatusOrder defines the ordering of AgentStatus.
type AgentStatusOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AgentStatusOrderField `json:"field"`
}

// DefaultAgentStatusOrder is the default ordering of AgentStatus.
var DefaultAgentStatusOrder = &AgentStatusOrder{
	Direction: OrderDirectionAsc,
	Field: &AgentStatusOrderField{
		field: agentstatus.FieldID,
		toCursor: func(as *AgentStatus) Cursor {
			return Cursor{ID: as.ID}
		},
	},
}

// ToEdge converts AgentStatus into AgentStatusEdge.
func (as *AgentStatus) ToEdge(order *AgentStatusOrder) *AgentStatusEdge {
	if order == nil {
		order = DefaultAgentStatusOrder
	}
	return &AgentStatusEdge{
		Node:   as,
		Cursor: order.Field.toCursor(as),
	}
}

// AgentTaskEdge is the edge representation of AgentTask.
type AgentTaskEdge struct {
	Node   *AgentTask `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// AgentTaskConnection is the connection containing edges to AgentTask.
type AgentTaskConnection struct {
	Edges      []*AgentTaskEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// AgentTaskPaginateOption enables pagination customization.
type AgentTaskPaginateOption func(*agentTaskPager) error

// WithAgentTaskOrder configures pagination ordering.
func WithAgentTaskOrder(order *AgentTaskOrder) AgentTaskPaginateOption {
	if order == nil {
		order = DefaultAgentTaskOrder
	}
	o := *order
	return func(pager *agentTaskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAgentTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAgentTaskFilter configures pagination filter.
func WithAgentTaskFilter(filter func(*AgentTaskQuery) (*AgentTaskQuery, error)) AgentTaskPaginateOption {
	return func(pager *agentTaskPager) error {
		if filter == nil {
			return errors.New("AgentTaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type agentTaskPager struct {
	order  *AgentTaskOrder
	filter func(*AgentTaskQuery) (*AgentTaskQuery, error)
}

func newAgentTaskPager(opts []AgentTaskPaginateOption) (*agentTaskPager, error) {
	pager := &agentTaskPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAgentTaskOrder
	}
	return pager, nil
}

func (p *agentTaskPager) applyFilter(query *AgentTaskQuery) (*AgentTaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *agentTaskPager) toCursor(at *AgentTask) Cursor {
	return p.order.Field.toCursor(at)
}

func (p *agentTaskPager) applyCursors(query *AgentTaskQuery, after, before *Cursor) *AgentTaskQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAgentTaskOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *agentTaskPager) applyOrder(query *AgentTaskQuery, reverse bool) *AgentTaskQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAgentTaskOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAgentTaskOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AgentTask.
func (at *AgentTaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AgentTaskPaginateOption,
) (*AgentTaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAgentTaskPager(opts)
	if err != nil {
		return nil, err
	}

	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}

	conn := &AgentTaskConnection{Edges: []*AgentTaskEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := at.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := at.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	at = pager.applyCursors(at, after, before)
	at = pager.applyOrder(at, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		at = at.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		at = at.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := at.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AgentTask
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AgentTask {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AgentTask {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AgentTaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AgentTaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AgentTaskOrderField defines the ordering field of AgentTask.
type AgentTaskOrderField struct {
	field    string
	toCursor func(*AgentTask) Cursor
}

// AgentTaskOrder defines the ordering of AgentTask.
type AgentTaskOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *AgentTaskOrderField `json:"field"`
}

// DefaultAgentTaskOrder is the default ordering of AgentTask.
var DefaultAgentTaskOrder = &AgentTaskOrder{
	Direction: OrderDirectionAsc,
	Field: &AgentTaskOrderField{
		field: agenttask.FieldID,
		toCursor: func(at *AgentTask) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts AgentTask into AgentTaskEdge.
func (at *AgentTask) ToEdge(order *AgentTaskOrder) *AgentTaskEdge {
	if order == nil {
		order = DefaultAgentTaskOrder
	}
	return &AgentTaskEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// AuthUserEdge is the edge representation of AuthUser.
type AuthUserEdge struct {
	Node   *AuthUser `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuthUserConnection is the connection containing edges to AuthUser.
type AuthUserConnection struct {
	Edges      []*AuthUserEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// AuthUserPaginateOption enables pagination customization.
type AuthUserPaginateOption func(*authUserPager) error

// WithAuthUserOrder configures pagination ordering.
func WithAuthUserOrder(order *AuthUserOrder) AuthUserPaginateOption {
	if order == nil {
		order = DefaultAuthUserOrder
	}
	o := *order
	return func(pager *authUserPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuthUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuthUserFilter configures pagination filter.
func WithAuthUserFilter(filter func(*AuthUserQuery) (*AuthUserQuery, error)) AuthUserPaginateOption {
	return func(pager *authUserPager) error {
		if filter == nil {
			return errors.New("AuthUserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authUserPager struct {
	order  *AuthUserOrder
	filter func(*AuthUserQuery) (*AuthUserQuery, error)
}

func newAuthUserPager(opts []AuthUserPaginateOption) (*authUserPager, error) {
	pager := &authUserPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuthUserOrder
	}
	return pager, nil
}

func (p *authUserPager) applyFilter(query *AuthUserQuery) (*AuthUserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authUserPager) toCursor(au *AuthUser) Cursor {
	return p.order.Field.toCursor(au)
}

func (p *authUserPager) applyCursors(query *AuthUserQuery, after, before *Cursor) *AuthUserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAuthUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *authUserPager) applyOrder(query *AuthUserQuery, reverse bool) *AuthUserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAuthUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAuthUserOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AuthUser.
func (au *AuthUserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthUserPaginateOption,
) (*AuthUserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthUserPager(opts)
	if err != nil {
		return nil, err
	}

	if au, err = pager.applyFilter(au); err != nil {
		return nil, err
	}

	conn := &AuthUserConnection{Edges: []*AuthUserEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := au.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := au.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	au = pager.applyCursors(au, after, before)
	au = pager.applyOrder(au, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		au = au.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		au = au.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := au.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AuthUser
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuthUser {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuthUser {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AuthUserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AuthUserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AuthUserOrderField defines the ordering field of AuthUser.
type AuthUserOrderField struct {
	field    string
	toCursor func(*AuthUser) Cursor
}

// AuthUserOrder defines the ordering of AuthUser.
type AuthUserOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuthUserOrderField `json:"field"`
}

// DefaultAuthUserOrder is the default ordering of AuthUser.
var DefaultAuthUserOrder = &AuthUserOrder{
	Direction: OrderDirectionAsc,
	Field: &AuthUserOrderField{
		field: authuser.FieldID,
		toCursor: func(au *AuthUser) Cursor {
			return Cursor{ID: au.ID}
		},
	},
}

// ToEdge converts AuthUser into AuthUserEdge.
func (au *AuthUser) ToEdge(order *AuthUserOrder) *AuthUserEdge {
	if order == nil {
		order = DefaultAuthUserOrder
	}
	return &AuthUserEdge{
		Node:   au,
		Cursor: order.Field.toCursor(au),
	}
}

// BuildEdge is the edge representation of Build.
type BuildEdge struct {
	Node   *Build `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BuildConnection is the connection containing edges to Build.
type BuildConnection struct {
	Edges      []*BuildEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// BuildPaginateOption enables pagination customization.
type BuildPaginateOption func(*buildPager) error

// WithBuildOrder configures pagination ordering.
func WithBuildOrder(order *BuildOrder) BuildPaginateOption {
	if order == nil {
		order = DefaultBuildOrder
	}
	o := *order
	return func(pager *buildPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBuildOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBuildFilter configures pagination filter.
func WithBuildFilter(filter func(*BuildQuery) (*BuildQuery, error)) BuildPaginateOption {
	return func(pager *buildPager) error {
		if filter == nil {
			return errors.New("BuildQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type buildPager struct {
	order  *BuildOrder
	filter func(*BuildQuery) (*BuildQuery, error)
}

func newBuildPager(opts []BuildPaginateOption) (*buildPager, error) {
	pager := &buildPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBuildOrder
	}
	return pager, nil
}

func (p *buildPager) applyFilter(query *BuildQuery) (*BuildQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *buildPager) toCursor(b *Build) Cursor {
	return p.order.Field.toCursor(b)
}

func (p *buildPager) applyCursors(query *BuildQuery, after, before *Cursor) *BuildQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBuildOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *buildPager) applyOrder(query *BuildQuery, reverse bool) *BuildQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBuildOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBuildOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Build.
func (b *BuildQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BuildPaginateOption,
) (*BuildConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBuildPager(opts)
	if err != nil {
		return nil, err
	}

	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}

	conn := &BuildConnection{Edges: []*BuildEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := b.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := b.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	b = pager.applyCursors(b, after, before)
	b = pager.applyOrder(b, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		b = b.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		b = b.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := b.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Build
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Build {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Build {
			return nodes[i]
		}
	}

	conn.Edges = make([]*BuildEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &BuildEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// BuildOrderField defines the ordering field of Build.
type BuildOrderField struct {
	field    string
	toCursor func(*Build) Cursor
}

// BuildOrder defines the ordering of Build.
type BuildOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *BuildOrderField `json:"field"`
}

// DefaultBuildOrder is the default ordering of Build.
var DefaultBuildOrder = &BuildOrder{
	Direction: OrderDirectionAsc,
	Field: &BuildOrderField{
		field: build.FieldID,
		toCursor: func(b *Build) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Build into BuildEdge.
func (b *Build) ToEdge(order *BuildOrder) *BuildEdge {
	if order == nil {
		order = DefaultBuildOrder
	}
	return &BuildEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// BuildCommitEdge is the edge representation of BuildCommit.
type BuildCommitEdge struct {
	Node   *BuildCommit `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// BuildCommitConnection is the connection containing edges to BuildCommit.
type BuildCommitConnection struct {
	Edges      []*BuildCommitEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// BuildCommitPaginateOption enables pagination customization.
type BuildCommitPaginateOption func(*buildCommitPager) error

// WithBuildCommitOrder configures pagination ordering.
func WithBuildCommitOrder(order *BuildCommitOrder) BuildCommitPaginateOption {
	if order == nil {
		order = DefaultBuildCommitOrder
	}
	o := *order
	return func(pager *buildCommitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBuildCommitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBuildCommitFilter configures pagination filter.
func WithBuildCommitFilter(filter func(*BuildCommitQuery) (*BuildCommitQuery, error)) BuildCommitPaginateOption {
	return func(pager *buildCommitPager) error {
		if filter == nil {
			return errors.New("BuildCommitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type buildCommitPager struct {
	order  *BuildCommitOrder
	filter func(*BuildCommitQuery) (*BuildCommitQuery, error)
}

func newBuildCommitPager(opts []BuildCommitPaginateOption) (*buildCommitPager, error) {
	pager := &buildCommitPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBuildCommitOrder
	}
	return pager, nil
}

func (p *buildCommitPager) applyFilter(query *BuildCommitQuery) (*BuildCommitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *buildCommitPager) toCursor(bc *BuildCommit) Cursor {
	return p.order.Field.toCursor(bc)
}

func (p *buildCommitPager) applyCursors(query *BuildCommitQuery, after, before *Cursor) *BuildCommitQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBuildCommitOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *buildCommitPager) applyOrder(query *BuildCommitQuery, reverse bool) *BuildCommitQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBuildCommitOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBuildCommitOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to BuildCommit.
func (bc *BuildCommitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BuildCommitPaginateOption,
) (*BuildCommitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBuildCommitPager(opts)
	if err != nil {
		return nil, err
	}

	if bc, err = pager.applyFilter(bc); err != nil {
		return nil, err
	}

	conn := &BuildCommitConnection{Edges: []*BuildCommitEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := bc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := bc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	bc = pager.applyCursors(bc, after, before)
	bc = pager.applyOrder(bc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		bc = bc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		bc = bc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := bc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *BuildCommit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BuildCommit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BuildCommit {
			return nodes[i]
		}
	}

	conn.Edges = make([]*BuildCommitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &BuildCommitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// BuildCommitOrderField defines the ordering field of BuildCommit.
type BuildCommitOrderField struct {
	field    string
	toCursor func(*BuildCommit) Cursor
}

// BuildCommitOrder defines the ordering of BuildCommit.
type BuildCommitOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *BuildCommitOrderField `json:"field"`
}

// DefaultBuildCommitOrder is the default ordering of BuildCommit.
var DefaultBuildCommitOrder = &BuildCommitOrder{
	Direction: OrderDirectionAsc,
	Field: &BuildCommitOrderField{
		field: buildcommit.FieldID,
		toCursor: func(bc *BuildCommit) Cursor {
			return Cursor{ID: bc.ID}
		},
	},
}

// ToEdge converts BuildCommit into BuildCommitEdge.
func (bc *BuildCommit) ToEdge(order *BuildCommitOrder) *BuildCommitEdge {
	if order == nil {
		order = DefaultBuildCommitOrder
	}
	return &BuildCommitEdge{
		Node:   bc,
		Cursor: order.Field.toCursor(bc),
	}
}

// CommandEdge is the edge representation of Command.
type CommandEdge struct {
	Node   *Command `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CommandConnection is the connection containing edges to Command.
type CommandConnection struct {
	Edges      []*CommandEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// CommandPaginateOption enables pagination customization.
type CommandPaginateOption func(*commandPager) error

// WithCommandOrder configures pagination ordering.
func WithCommandOrder(order *CommandOrder) CommandPaginateOption {
	if order == nil {
		order = DefaultCommandOrder
	}
	o := *order
	return func(pager *commandPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCommandOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCommandFilter configures pagination filter.
func WithCommandFilter(filter func(*CommandQuery) (*CommandQuery, error)) CommandPaginateOption {
	return func(pager *commandPager) error {
		if filter == nil {
			return errors.New("CommandQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type commandPager struct {
	order  *CommandOrder
	filter func(*CommandQuery) (*CommandQuery, error)
}

func newCommandPager(opts []CommandPaginateOption) (*commandPager, error) {
	pager := &commandPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCommandOrder
	}
	return pager, nil
}

func (p *commandPager) applyFilter(query *CommandQuery) (*CommandQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *commandPager) toCursor(c *Command) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *commandPager) applyCursors(query *CommandQuery, after, before *Cursor) *CommandQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCommandOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *commandPager) applyOrder(query *CommandQuery, reverse bool) *CommandQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCommandOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCommandOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Command.
func (c *CommandQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CommandPaginateOption,
) (*CommandConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommandPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CommandConnection{Edges: []*CommandEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Command
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Command {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Command {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CommandEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CommandEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CommandOrderField defines the ordering field of Command.
type CommandOrderField struct {
	field    string
	toCursor func(*Command) Cursor
}

// CommandOrder defines the ordering of Command.
type CommandOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CommandOrderField `json:"field"`
}

// DefaultCommandOrder is the default ordering of Command.
var DefaultCommandOrder = &CommandOrder{
	Direction: OrderDirectionAsc,
	Field: &CommandOrderField{
		field: command.FieldID,
		toCursor: func(c *Command) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Command into CommandEdge.
func (c *Command) ToEdge(order *CommandOrder) *CommandEdge {
	if order == nil {
		order = DefaultCommandOrder
	}
	return &CommandEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CompetitionEdge is the edge representation of Competition.
type CompetitionEdge struct {
	Node   *Competition `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// CompetitionConnection is the connection containing edges to Competition.
type CompetitionConnection struct {
	Edges      []*CompetitionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// CompetitionPaginateOption enables pagination customization.
type CompetitionPaginateOption func(*competitionPager) error

// WithCompetitionOrder configures pagination ordering.
func WithCompetitionOrder(order *CompetitionOrder) CompetitionPaginateOption {
	if order == nil {
		order = DefaultCompetitionOrder
	}
	o := *order
	return func(pager *competitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompetitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompetitionFilter configures pagination filter.
func WithCompetitionFilter(filter func(*CompetitionQuery) (*CompetitionQuery, error)) CompetitionPaginateOption {
	return func(pager *competitionPager) error {
		if filter == nil {
			return errors.New("CompetitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type competitionPager struct {
	order  *CompetitionOrder
	filter func(*CompetitionQuery) (*CompetitionQuery, error)
}

func newCompetitionPager(opts []CompetitionPaginateOption) (*competitionPager, error) {
	pager := &competitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompetitionOrder
	}
	return pager, nil
}

func (p *competitionPager) applyFilter(query *CompetitionQuery) (*CompetitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *competitionPager) toCursor(c *Competition) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *competitionPager) applyCursors(query *CompetitionQuery, after, before *Cursor) *CompetitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCompetitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *competitionPager) applyOrder(query *CompetitionQuery, reverse bool) *CompetitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCompetitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCompetitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Competition.
func (c *CompetitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompetitionPaginateOption,
) (*CompetitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompetitionPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CompetitionConnection{Edges: []*CompetitionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Competition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Competition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Competition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CompetitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CompetitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CompetitionOrderField defines the ordering field of Competition.
type CompetitionOrderField struct {
	field    string
	toCursor func(*Competition) Cursor
}

// CompetitionOrder defines the ordering of Competition.
type CompetitionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *CompetitionOrderField `json:"field"`
}

// DefaultCompetitionOrder is the default ordering of Competition.
var DefaultCompetitionOrder = &CompetitionOrder{
	Direction: OrderDirectionAsc,
	Field: &CompetitionOrderField{
		field: competition.FieldID,
		toCursor: func(c *Competition) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Competition into CompetitionEdge.
func (c *Competition) ToEdge(order *CompetitionOrder) *CompetitionEdge {
	if order == nil {
		order = DefaultCompetitionOrder
	}
	return &CompetitionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DNSEdge is the edge representation of DNS.
type DNSEdge struct {
	Node   *DNS   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// DNSConnection is the connection containing edges to DNS.
type DNSConnection struct {
	Edges      []*DNSEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// DNSPaginateOption enables pagination customization.
type DNSPaginateOption func(*dNSPager) error

// WithDNSOrder configures pagination ordering.
func WithDNSOrder(order *DNSOrder) DNSPaginateOption {
	if order == nil {
		order = DefaultDNSOrder
	}
	o := *order
	return func(pager *dNSPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSFilter configures pagination filter.
func WithDNSFilter(filter func(*DNSQuery) (*DNSQuery, error)) DNSPaginateOption {
	return func(pager *dNSPager) error {
		if filter == nil {
			return errors.New("DNSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dNSPager struct {
	order  *DNSOrder
	filter func(*DNSQuery) (*DNSQuery, error)
}

func newDNSPager(opts []DNSPaginateOption) (*dNSPager, error) {
	pager := &dNSPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSOrder
	}
	return pager, nil
}

func (p *dNSPager) applyFilter(query *DNSQuery) (*DNSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dNSPager) toCursor(d *DNS) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *dNSPager) applyCursors(query *DNSQuery, after, before *Cursor) *DNSQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDNSOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *dNSPager) applyOrder(query *DNSQuery, reverse bool) *DNSQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDNSOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDNSOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DNS.
func (d *DNSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSPaginateOption,
) (*DNSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSPager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}

	conn := &DNSConnection{Edges: []*DNSEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := d.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := d.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	d = pager.applyCursors(d, after, before)
	d = pager.applyOrder(d, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		d = d.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		d = d.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := d.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DNS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNS {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DNSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DNSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DNSOrderField defines the ordering field of DNS.
type DNSOrderField struct {
	field    string
	toCursor func(*DNS) Cursor
}

// DNSOrder defines the ordering of DNS.
type DNSOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *DNSOrderField `json:"field"`
}

// DefaultDNSOrder is the default ordering of DNS.
var DefaultDNSOrder = &DNSOrder{
	Direction: OrderDirectionAsc,
	Field: &DNSOrderField{
		field: dns.FieldID,
		toCursor: func(d *DNS) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts DNS into DNSEdge.
func (d *DNS) ToEdge(order *DNSOrder) *DNSEdge {
	if order == nil {
		order = DefaultDNSOrder
	}
	return &DNSEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// DNSRecordEdge is the edge representation of DNSRecord.
type DNSRecordEdge struct {
	Node   *DNSRecord `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// DNSRecordConnection is the connection containing edges to DNSRecord.
type DNSRecordConnection struct {
	Edges      []*DNSRecordEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// DNSRecordPaginateOption enables pagination customization.
type DNSRecordPaginateOption func(*dNSRecordPager) error

// WithDNSRecordOrder configures pagination ordering.
func WithDNSRecordOrder(order *DNSRecordOrder) DNSRecordPaginateOption {
	if order == nil {
		order = DefaultDNSRecordOrder
	}
	o := *order
	return func(pager *dNSRecordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSRecordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSRecordFilter configures pagination filter.
func WithDNSRecordFilter(filter func(*DNSRecordQuery) (*DNSRecordQuery, error)) DNSRecordPaginateOption {
	return func(pager *dNSRecordPager) error {
		if filter == nil {
			return errors.New("DNSRecordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dNSRecordPager struct {
	order  *DNSRecordOrder
	filter func(*DNSRecordQuery) (*DNSRecordQuery, error)
}

func newDNSRecordPager(opts []DNSRecordPaginateOption) (*dNSRecordPager, error) {
	pager := &dNSRecordPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSRecordOrder
	}
	return pager, nil
}

func (p *dNSRecordPager) applyFilter(query *DNSRecordQuery) (*DNSRecordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dNSRecordPager) toCursor(dr *DNSRecord) Cursor {
	return p.order.Field.toCursor(dr)
}

func (p *dNSRecordPager) applyCursors(query *DNSRecordQuery, after, before *Cursor) *DNSRecordQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDNSRecordOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *dNSRecordPager) applyOrder(query *DNSRecordQuery, reverse bool) *DNSRecordQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDNSRecordOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDNSRecordOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DNSRecord.
func (dr *DNSRecordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSRecordPaginateOption,
) (*DNSRecordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSRecordPager(opts)
	if err != nil {
		return nil, err
	}

	if dr, err = pager.applyFilter(dr); err != nil {
		return nil, err
	}

	conn := &DNSRecordConnection{Edges: []*DNSRecordEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := dr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := dr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	dr = pager.applyCursors(dr, after, before)
	dr = pager.applyOrder(dr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		dr = dr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		dr = dr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := dr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DNSRecord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSRecord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSRecord {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DNSRecordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DNSRecordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DNSRecordOrderField defines the ordering field of DNSRecord.
type DNSRecordOrderField struct {
	field    string
	toCursor func(*DNSRecord) Cursor
}

// DNSRecordOrder defines the ordering of DNSRecord.
type DNSRecordOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *DNSRecordOrderField `json:"field"`
}

// DefaultDNSRecordOrder is the default ordering of DNSRecord.
var DefaultDNSRecordOrder = &DNSRecordOrder{
	Direction: OrderDirectionAsc,
	Field: &DNSRecordOrderField{
		field: dnsrecord.FieldID,
		toCursor: func(dr *DNSRecord) Cursor {
			return Cursor{ID: dr.ID}
		},
	},
}

// ToEdge converts DNSRecord into DNSRecordEdge.
func (dr *DNSRecord) ToEdge(order *DNSRecordOrder) *DNSRecordEdge {
	if order == nil {
		order = DefaultDNSRecordOrder
	}
	return &DNSRecordEdge{
		Node:   dr,
		Cursor: order.Field.toCursor(dr),
	}
}

// DiskEdge is the edge representation of Disk.
type DiskEdge struct {
	Node   *Disk  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// DiskConnection is the connection containing edges to Disk.
type DiskConnection struct {
	Edges      []*DiskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// DiskPaginateOption enables pagination customization.
type DiskPaginateOption func(*diskPager) error

// WithDiskOrder configures pagination ordering.
func WithDiskOrder(order *DiskOrder) DiskPaginateOption {
	if order == nil {
		order = DefaultDiskOrder
	}
	o := *order
	return func(pager *diskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDiskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDiskFilter configures pagination filter.
func WithDiskFilter(filter func(*DiskQuery) (*DiskQuery, error)) DiskPaginateOption {
	return func(pager *diskPager) error {
		if filter == nil {
			return errors.New("DiskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type diskPager struct {
	order  *DiskOrder
	filter func(*DiskQuery) (*DiskQuery, error)
}

func newDiskPager(opts []DiskPaginateOption) (*diskPager, error) {
	pager := &diskPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDiskOrder
	}
	return pager, nil
}

func (p *diskPager) applyFilter(query *DiskQuery) (*DiskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *diskPager) toCursor(d *Disk) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *diskPager) applyCursors(query *DiskQuery, after, before *Cursor) *DiskQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDiskOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *diskPager) applyOrder(query *DiskQuery, reverse bool) *DiskQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDiskOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDiskOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Disk.
func (d *DiskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DiskPaginateOption,
) (*DiskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDiskPager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}

	conn := &DiskConnection{Edges: []*DiskEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := d.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := d.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	d = pager.applyCursors(d, after, before)
	d = pager.applyOrder(d, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		d = d.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		d = d.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := d.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Disk
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Disk {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Disk {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DiskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DiskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DiskOrderField defines the ordering field of Disk.
type DiskOrderField struct {
	field    string
	toCursor func(*Disk) Cursor
}

// DiskOrder defines the ordering of Disk.
type DiskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *DiskOrderField `json:"field"`
}

// DefaultDiskOrder is the default ordering of Disk.
var DefaultDiskOrder = &DiskOrder{
	Direction: OrderDirectionAsc,
	Field: &DiskOrderField{
		field: disk.FieldID,
		toCursor: func(d *Disk) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Disk into DiskEdge.
func (d *Disk) ToEdge(order *DiskOrder) *DiskEdge {
	if order == nil {
		order = DefaultDiskOrder
	}
	return &DiskEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// EnvironmentEdge is the edge representation of Environment.
type EnvironmentEdge struct {
	Node   *Environment `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// EnvironmentConnection is the connection containing edges to Environment.
type EnvironmentConnection struct {
	Edges      []*EnvironmentEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// EnvironmentPaginateOption enables pagination customization.
type EnvironmentPaginateOption func(*environmentPager) error

// WithEnvironmentOrder configures pagination ordering.
func WithEnvironmentOrder(order *EnvironmentOrder) EnvironmentPaginateOption {
	if order == nil {
		order = DefaultEnvironmentOrder
	}
	o := *order
	return func(pager *environmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEnvironmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEnvironmentFilter configures pagination filter.
func WithEnvironmentFilter(filter func(*EnvironmentQuery) (*EnvironmentQuery, error)) EnvironmentPaginateOption {
	return func(pager *environmentPager) error {
		if filter == nil {
			return errors.New("EnvironmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type environmentPager struct {
	order  *EnvironmentOrder
	filter func(*EnvironmentQuery) (*EnvironmentQuery, error)
}

func newEnvironmentPager(opts []EnvironmentPaginateOption) (*environmentPager, error) {
	pager := &environmentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEnvironmentOrder
	}
	return pager, nil
}

func (p *environmentPager) applyFilter(query *EnvironmentQuery) (*EnvironmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *environmentPager) toCursor(e *Environment) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *environmentPager) applyCursors(query *EnvironmentQuery, after, before *Cursor) *EnvironmentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEnvironmentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *environmentPager) applyOrder(query *EnvironmentQuery, reverse bool) *EnvironmentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEnvironmentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEnvironmentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Environment.
func (e *EnvironmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EnvironmentPaginateOption,
) (*EnvironmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEnvironmentPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}

	conn := &EnvironmentConnection{Edges: []*EnvironmentEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := e.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := e.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		e = e.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := e.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Environment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Environment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Environment {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EnvironmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EnvironmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EnvironmentOrderField defines the ordering field of Environment.
type EnvironmentOrderField struct {
	field    string
	toCursor func(*Environment) Cursor
}

// EnvironmentOrder defines the ordering of Environment.
type EnvironmentOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *EnvironmentOrderField `json:"field"`
}

// DefaultEnvironmentOrder is the default ordering of Environment.
var DefaultEnvironmentOrder = &EnvironmentOrder{
	Direction: OrderDirectionAsc,
	Field: &EnvironmentOrderField{
		field: environment.FieldID,
		toCursor: func(e *Environment) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Environment into EnvironmentEdge.
func (e *Environment) ToEdge(order *EnvironmentOrder) *EnvironmentEdge {
	if order == nil {
		order = DefaultEnvironmentOrder
	}
	return &EnvironmentEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// FileDeleteEdge is the edge representation of FileDelete.
type FileDeleteEdge struct {
	Node   *FileDelete `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// FileDeleteConnection is the connection containing edges to FileDelete.
type FileDeleteConnection struct {
	Edges      []*FileDeleteEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// FileDeletePaginateOption enables pagination customization.
type FileDeletePaginateOption func(*fileDeletePager) error

// WithFileDeleteOrder configures pagination ordering.
func WithFileDeleteOrder(order *FileDeleteOrder) FileDeletePaginateOption {
	if order == nil {
		order = DefaultFileDeleteOrder
	}
	o := *order
	return func(pager *fileDeletePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileDeleteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileDeleteFilter configures pagination filter.
func WithFileDeleteFilter(filter func(*FileDeleteQuery) (*FileDeleteQuery, error)) FileDeletePaginateOption {
	return func(pager *fileDeletePager) error {
		if filter == nil {
			return errors.New("FileDeleteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fileDeletePager struct {
	order  *FileDeleteOrder
	filter func(*FileDeleteQuery) (*FileDeleteQuery, error)
}

func newFileDeletePager(opts []FileDeletePaginateOption) (*fileDeletePager, error) {
	pager := &fileDeletePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileDeleteOrder
	}
	return pager, nil
}

func (p *fileDeletePager) applyFilter(query *FileDeleteQuery) (*FileDeleteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fileDeletePager) toCursor(fd *FileDelete) Cursor {
	return p.order.Field.toCursor(fd)
}

func (p *fileDeletePager) applyCursors(query *FileDeleteQuery, after, before *Cursor) *FileDeleteQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileDeleteOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *fileDeletePager) applyOrder(query *FileDeleteQuery, reverse bool) *FileDeleteQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileDeleteOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileDeleteOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FileDelete.
func (fd *FileDeleteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileDeletePaginateOption,
) (*FileDeleteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileDeletePager(opts)
	if err != nil {
		return nil, err
	}

	if fd, err = pager.applyFilter(fd); err != nil {
		return nil, err
	}

	conn := &FileDeleteConnection{Edges: []*FileDeleteEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := fd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fd = pager.applyCursors(fd, after, before)
	fd = pager.applyOrder(fd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fd = fd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fd = fd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FileDelete
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileDelete {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileDelete {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FileDeleteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FileDeleteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FileDeleteOrderField defines the ordering field of FileDelete.
type FileDeleteOrderField struct {
	field    string
	toCursor func(*FileDelete) Cursor
}

// FileDeleteOrder defines the ordering of FileDelete.
type FileDeleteOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *FileDeleteOrderField `json:"field"`
}

// DefaultFileDeleteOrder is the default ordering of FileDelete.
var DefaultFileDeleteOrder = &FileDeleteOrder{
	Direction: OrderDirectionAsc,
	Field: &FileDeleteOrderField{
		field: filedelete.FieldID,
		toCursor: func(fd *FileDelete) Cursor {
			return Cursor{ID: fd.ID}
		},
	},
}

// ToEdge converts FileDelete into FileDeleteEdge.
func (fd *FileDelete) ToEdge(order *FileDeleteOrder) *FileDeleteEdge {
	if order == nil {
		order = DefaultFileDeleteOrder
	}
	return &FileDeleteEdge{
		Node:   fd,
		Cursor: order.Field.toCursor(fd),
	}
}

// FileDownloadEdge is the edge representation of FileDownload.
type FileDownloadEdge struct {
	Node   *FileDownload `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// FileDownloadConnection is the connection containing edges to FileDownload.
type FileDownloadConnection struct {
	Edges      []*FileDownloadEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// FileDownloadPaginateOption enables pagination customization.
type FileDownloadPaginateOption func(*fileDownloadPager) error

// WithFileDownloadOrder configures pagination ordering.
func WithFileDownloadOrder(order *FileDownloadOrder) FileDownloadPaginateOption {
	if order == nil {
		order = DefaultFileDownloadOrder
	}
	o := *order
	return func(pager *fileDownloadPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileDownloadOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileDownloadFilter configures pagination filter.
func WithFileDownloadFilter(filter func(*FileDownloadQuery) (*FileDownloadQuery, error)) FileDownloadPaginateOption {
	return func(pager *fileDownloadPager) error {
		if filter == nil {
			return errors.New("FileDownloadQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fileDownloadPager struct {
	order  *FileDownloadOrder
	filter func(*FileDownloadQuery) (*FileDownloadQuery, error)
}

func newFileDownloadPager(opts []FileDownloadPaginateOption) (*fileDownloadPager, error) {
	pager := &fileDownloadPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileDownloadOrder
	}
	return pager, nil
}

func (p *fileDownloadPager) applyFilter(query *FileDownloadQuery) (*FileDownloadQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fileDownloadPager) toCursor(fd *FileDownload) Cursor {
	return p.order.Field.toCursor(fd)
}

func (p *fileDownloadPager) applyCursors(query *FileDownloadQuery, after, before *Cursor) *FileDownloadQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileDownloadOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *fileDownloadPager) applyOrder(query *FileDownloadQuery, reverse bool) *FileDownloadQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileDownloadOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileDownloadOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FileDownload.
func (fd *FileDownloadQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileDownloadPaginateOption,
) (*FileDownloadConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileDownloadPager(opts)
	if err != nil {
		return nil, err
	}

	if fd, err = pager.applyFilter(fd); err != nil {
		return nil, err
	}

	conn := &FileDownloadConnection{Edges: []*FileDownloadEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := fd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fd = pager.applyCursors(fd, after, before)
	fd = pager.applyOrder(fd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fd = fd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fd = fd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FileDownload
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileDownload {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileDownload {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FileDownloadEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FileDownloadEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FileDownloadOrderField defines the ordering field of FileDownload.
type FileDownloadOrderField struct {
	field    string
	toCursor func(*FileDownload) Cursor
}

// FileDownloadOrder defines the ordering of FileDownload.
type FileDownloadOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *FileDownloadOrderField `json:"field"`
}

// DefaultFileDownloadOrder is the default ordering of FileDownload.
var DefaultFileDownloadOrder = &FileDownloadOrder{
	Direction: OrderDirectionAsc,
	Field: &FileDownloadOrderField{
		field: filedownload.FieldID,
		toCursor: func(fd *FileDownload) Cursor {
			return Cursor{ID: fd.ID}
		},
	},
}

// ToEdge converts FileDownload into FileDownloadEdge.
func (fd *FileDownload) ToEdge(order *FileDownloadOrder) *FileDownloadEdge {
	if order == nil {
		order = DefaultFileDownloadOrder
	}
	return &FileDownloadEdge{
		Node:   fd,
		Cursor: order.Field.toCursor(fd),
	}
}

// FileExtractEdge is the edge representation of FileExtract.
type FileExtractEdge struct {
	Node   *FileExtract `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// FileExtractConnection is the connection containing edges to FileExtract.
type FileExtractConnection struct {
	Edges      []*FileExtractEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// FileExtractPaginateOption enables pagination customization.
type FileExtractPaginateOption func(*fileExtractPager) error

// WithFileExtractOrder configures pagination ordering.
func WithFileExtractOrder(order *FileExtractOrder) FileExtractPaginateOption {
	if order == nil {
		order = DefaultFileExtractOrder
	}
	o := *order
	return func(pager *fileExtractPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileExtractOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileExtractFilter configures pagination filter.
func WithFileExtractFilter(filter func(*FileExtractQuery) (*FileExtractQuery, error)) FileExtractPaginateOption {
	return func(pager *fileExtractPager) error {
		if filter == nil {
			return errors.New("FileExtractQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fileExtractPager struct {
	order  *FileExtractOrder
	filter func(*FileExtractQuery) (*FileExtractQuery, error)
}

func newFileExtractPager(opts []FileExtractPaginateOption) (*fileExtractPager, error) {
	pager := &fileExtractPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileExtractOrder
	}
	return pager, nil
}

func (p *fileExtractPager) applyFilter(query *FileExtractQuery) (*FileExtractQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fileExtractPager) toCursor(fe *FileExtract) Cursor {
	return p.order.Field.toCursor(fe)
}

func (p *fileExtractPager) applyCursors(query *FileExtractQuery, after, before *Cursor) *FileExtractQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileExtractOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *fileExtractPager) applyOrder(query *FileExtractQuery, reverse bool) *FileExtractQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileExtractOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileExtractOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FileExtract.
func (fe *FileExtractQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileExtractPaginateOption,
) (*FileExtractConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileExtractPager(opts)
	if err != nil {
		return nil, err
	}

	if fe, err = pager.applyFilter(fe); err != nil {
		return nil, err
	}

	conn := &FileExtractConnection{Edges: []*FileExtractEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fe.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := fe.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fe = pager.applyCursors(fe, after, before)
	fe = pager.applyOrder(fe, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fe = fe.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fe = fe.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fe.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FileExtract
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileExtract {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileExtract {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FileExtractEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FileExtractEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FileExtractOrderField defines the ordering field of FileExtract.
type FileExtractOrderField struct {
	field    string
	toCursor func(*FileExtract) Cursor
}

// FileExtractOrder defines the ordering of FileExtract.
type FileExtractOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *FileExtractOrderField `json:"field"`
}

// DefaultFileExtractOrder is the default ordering of FileExtract.
var DefaultFileExtractOrder = &FileExtractOrder{
	Direction: OrderDirectionAsc,
	Field: &FileExtractOrderField{
		field: fileextract.FieldID,
		toCursor: func(fe *FileExtract) Cursor {
			return Cursor{ID: fe.ID}
		},
	},
}

// ToEdge converts FileExtract into FileExtractEdge.
func (fe *FileExtract) ToEdge(order *FileExtractOrder) *FileExtractEdge {
	if order == nil {
		order = DefaultFileExtractOrder
	}
	return &FileExtractEdge{
		Node:   fe,
		Cursor: order.Field.toCursor(fe),
	}
}

// FindingEdge is the edge representation of Finding.
type FindingEdge struct {
	Node   *Finding `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FindingConnection is the connection containing edges to Finding.
type FindingConnection struct {
	Edges      []*FindingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// FindingPaginateOption enables pagination customization.
type FindingPaginateOption func(*findingPager) error

// WithFindingOrder configures pagination ordering.
func WithFindingOrder(order *FindingOrder) FindingPaginateOption {
	if order == nil {
		order = DefaultFindingOrder
	}
	o := *order
	return func(pager *findingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFindingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFindingFilter configures pagination filter.
func WithFindingFilter(filter func(*FindingQuery) (*FindingQuery, error)) FindingPaginateOption {
	return func(pager *findingPager) error {
		if filter == nil {
			return errors.New("FindingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingPager struct {
	order  *FindingOrder
	filter func(*FindingQuery) (*FindingQuery, error)
}

func newFindingPager(opts []FindingPaginateOption) (*findingPager, error) {
	pager := &findingPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFindingOrder
	}
	return pager, nil
}

func (p *findingPager) applyFilter(query *FindingQuery) (*FindingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingPager) toCursor(f *Finding) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *findingPager) applyCursors(query *FindingQuery, after, before *Cursor) *FindingQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFindingOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *findingPager) applyOrder(query *FindingQuery, reverse bool) *FindingQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFindingOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFindingOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Finding.
func (f *FindingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingPaginateOption,
) (*FindingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingPager(opts)
	if err != nil {
		return nil, err
	}

	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}

	conn := &FindingConnection{Edges: []*FindingEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := f.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := f.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		f = f.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		f = f.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := f.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Finding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Finding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Finding {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FindingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FindingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FindingOrderField defines the ordering field of Finding.
type FindingOrderField struct {
	field    string
	toCursor func(*Finding) Cursor
}

// FindingOrder defines the ordering of Finding.
type FindingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FindingOrderField `json:"field"`
}

// DefaultFindingOrder is the default ordering of Finding.
var DefaultFindingOrder = &FindingOrder{
	Direction: OrderDirectionAsc,
	Field: &FindingOrderField{
		field: finding.FieldID,
		toCursor: func(f *Finding) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts Finding into FindingEdge.
func (f *Finding) ToEdge(order *FindingOrder) *FindingEdge {
	if order == nil {
		order = DefaultFindingOrder
	}
	return &FindingEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// GinFileMiddlewareEdge is the edge representation of GinFileMiddleware.
type GinFileMiddlewareEdge struct {
	Node   *GinFileMiddleware `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// GinFileMiddlewareConnection is the connection containing edges to GinFileMiddleware.
type GinFileMiddlewareConnection struct {
	Edges      []*GinFileMiddlewareEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// GinFileMiddlewarePaginateOption enables pagination customization.
type GinFileMiddlewarePaginateOption func(*ginFileMiddlewarePager) error

// WithGinFileMiddlewareOrder configures pagination ordering.
func WithGinFileMiddlewareOrder(order *GinFileMiddlewareOrder) GinFileMiddlewarePaginateOption {
	if order == nil {
		order = DefaultGinFileMiddlewareOrder
	}
	o := *order
	return func(pager *ginFileMiddlewarePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGinFileMiddlewareOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGinFileMiddlewareFilter configures pagination filter.
func WithGinFileMiddlewareFilter(filter func(*GinFileMiddlewareQuery) (*GinFileMiddlewareQuery, error)) GinFileMiddlewarePaginateOption {
	return func(pager *ginFileMiddlewarePager) error {
		if filter == nil {
			return errors.New("GinFileMiddlewareQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ginFileMiddlewarePager struct {
	order  *GinFileMiddlewareOrder
	filter func(*GinFileMiddlewareQuery) (*GinFileMiddlewareQuery, error)
}

func newGinFileMiddlewarePager(opts []GinFileMiddlewarePaginateOption) (*ginFileMiddlewarePager, error) {
	pager := &ginFileMiddlewarePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGinFileMiddlewareOrder
	}
	return pager, nil
}

func (p *ginFileMiddlewarePager) applyFilter(query *GinFileMiddlewareQuery) (*GinFileMiddlewareQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ginFileMiddlewarePager) toCursor(gfm *GinFileMiddleware) Cursor {
	return p.order.Field.toCursor(gfm)
}

func (p *ginFileMiddlewarePager) applyCursors(query *GinFileMiddlewareQuery, after, before *Cursor) *GinFileMiddlewareQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultGinFileMiddlewareOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *ginFileMiddlewarePager) applyOrder(query *GinFileMiddlewareQuery, reverse bool) *GinFileMiddlewareQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultGinFileMiddlewareOrder.Field {
		query = query.Order(direction.orderFunc(DefaultGinFileMiddlewareOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to GinFileMiddleware.
func (gfm *GinFileMiddlewareQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GinFileMiddlewarePaginateOption,
) (*GinFileMiddlewareConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGinFileMiddlewarePager(opts)
	if err != nil {
		return nil, err
	}

	if gfm, err = pager.applyFilter(gfm); err != nil {
		return nil, err
	}

	conn := &GinFileMiddlewareConnection{Edges: []*GinFileMiddlewareEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := gfm.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := gfm.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	gfm = pager.applyCursors(gfm, after, before)
	gfm = pager.applyOrder(gfm, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		gfm = gfm.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		gfm = gfm.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := gfm.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *GinFileMiddleware
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GinFileMiddleware {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GinFileMiddleware {
			return nodes[i]
		}
	}

	conn.Edges = make([]*GinFileMiddlewareEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &GinFileMiddlewareEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// GinFileMiddlewareOrderField defines the ordering field of GinFileMiddleware.
type GinFileMiddlewareOrderField struct {
	field    string
	toCursor func(*GinFileMiddleware) Cursor
}

// GinFileMiddlewareOrder defines the ordering of GinFileMiddleware.
type GinFileMiddlewareOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *GinFileMiddlewareOrderField `json:"field"`
}

// DefaultGinFileMiddlewareOrder is the default ordering of GinFileMiddleware.
var DefaultGinFileMiddlewareOrder = &GinFileMiddlewareOrder{
	Direction: OrderDirectionAsc,
	Field: &GinFileMiddlewareOrderField{
		field: ginfilemiddleware.FieldID,
		toCursor: func(gfm *GinFileMiddleware) Cursor {
			return Cursor{ID: gfm.ID}
		},
	},
}

// ToEdge converts GinFileMiddleware into GinFileMiddlewareEdge.
func (gfm *GinFileMiddleware) ToEdge(order *GinFileMiddlewareOrder) *GinFileMiddlewareEdge {
	if order == nil {
		order = DefaultGinFileMiddlewareOrder
	}
	return &GinFileMiddlewareEdge{
		Node:   gfm,
		Cursor: order.Field.toCursor(gfm),
	}
}

// HostEdge is the edge representation of Host.
type HostEdge struct {
	Node   *Host  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// HostConnection is the connection containing edges to Host.
type HostConnection struct {
	Edges      []*HostEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// HostPaginateOption enables pagination customization.
type HostPaginateOption func(*hostPager) error

// WithHostOrder configures pagination ordering.
func WithHostOrder(order *HostOrder) HostPaginateOption {
	if order == nil {
		order = DefaultHostOrder
	}
	o := *order
	return func(pager *hostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHostFilter configures pagination filter.
func WithHostFilter(filter func(*HostQuery) (*HostQuery, error)) HostPaginateOption {
	return func(pager *hostPager) error {
		if filter == nil {
			return errors.New("HostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hostPager struct {
	order  *HostOrder
	filter func(*HostQuery) (*HostQuery, error)
}

func newHostPager(opts []HostPaginateOption) (*hostPager, error) {
	pager := &hostPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHostOrder
	}
	return pager, nil
}

func (p *hostPager) applyFilter(query *HostQuery) (*HostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hostPager) toCursor(h *Host) Cursor {
	return p.order.Field.toCursor(h)
}

func (p *hostPager) applyCursors(query *HostQuery, after, before *Cursor) *HostQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHostOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hostPager) applyOrder(query *HostQuery, reverse bool) *HostQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHostOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHostOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Host.
func (h *HostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HostPaginateOption,
) (*HostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHostPager(opts)
	if err != nil {
		return nil, err
	}

	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}

	conn := &HostConnection{Edges: []*HostEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := h.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := h.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	h = pager.applyCursors(h, after, before)
	h = pager.applyOrder(h, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		h = h.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		h = h.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := h.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Host
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Host {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Host {
			return nodes[i]
		}
	}

	conn.Edges = make([]*HostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &HostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// HostOrderField defines the ordering field of Host.
type HostOrderField struct {
	field    string
	toCursor func(*Host) Cursor
}

// HostOrder defines the ordering of Host.
type HostOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *HostOrderField `json:"field"`
}

// DefaultHostOrder is the default ordering of Host.
var DefaultHostOrder = &HostOrder{
	Direction: OrderDirectionAsc,
	Field: &HostOrderField{
		field: host.FieldID,
		toCursor: func(h *Host) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Host into HostEdge.
func (h *Host) ToEdge(order *HostOrder) *HostEdge {
	if order == nil {
		order = DefaultHostOrder
	}
	return &HostEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// HostDependencyEdge is the edge representation of HostDependency.
type HostDependencyEdge struct {
	Node   *HostDependency `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// HostDependencyConnection is the connection containing edges to HostDependency.
type HostDependencyConnection struct {
	Edges      []*HostDependencyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// HostDependencyPaginateOption enables pagination customization.
type HostDependencyPaginateOption func(*hostDependencyPager) error

// WithHostDependencyOrder configures pagination ordering.
func WithHostDependencyOrder(order *HostDependencyOrder) HostDependencyPaginateOption {
	if order == nil {
		order = DefaultHostDependencyOrder
	}
	o := *order
	return func(pager *hostDependencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHostDependencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHostDependencyFilter configures pagination filter.
func WithHostDependencyFilter(filter func(*HostDependencyQuery) (*HostDependencyQuery, error)) HostDependencyPaginateOption {
	return func(pager *hostDependencyPager) error {
		if filter == nil {
			return errors.New("HostDependencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hostDependencyPager struct {
	order  *HostDependencyOrder
	filter func(*HostDependencyQuery) (*HostDependencyQuery, error)
}

func newHostDependencyPager(opts []HostDependencyPaginateOption) (*hostDependencyPager, error) {
	pager := &hostDependencyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHostDependencyOrder
	}
	return pager, nil
}

func (p *hostDependencyPager) applyFilter(query *HostDependencyQuery) (*HostDependencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hostDependencyPager) toCursor(hd *HostDependency) Cursor {
	return p.order.Field.toCursor(hd)
}

func (p *hostDependencyPager) applyCursors(query *HostDependencyQuery, after, before *Cursor) *HostDependencyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHostDependencyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hostDependencyPager) applyOrder(query *HostDependencyQuery, reverse bool) *HostDependencyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHostDependencyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHostDependencyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to HostDependency.
func (hd *HostDependencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HostDependencyPaginateOption,
) (*HostDependencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHostDependencyPager(opts)
	if err != nil {
		return nil, err
	}

	if hd, err = pager.applyFilter(hd); err != nil {
		return nil, err
	}

	conn := &HostDependencyConnection{Edges: []*HostDependencyEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := hd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := hd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	hd = pager.applyCursors(hd, after, before)
	hd = pager.applyOrder(hd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		hd = hd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		hd = hd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := hd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *HostDependency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HostDependency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HostDependency {
			return nodes[i]
		}
	}

	conn.Edges = make([]*HostDependencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &HostDependencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// HostDependencyOrderField defines the ordering field of HostDependency.
type HostDependencyOrderField struct {
	field    string
	toCursor func(*HostDependency) Cursor
}

// HostDependencyOrder defines the ordering of HostDependency.
type HostDependencyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *HostDependencyOrderField `json:"field"`
}

// DefaultHostDependencyOrder is the default ordering of HostDependency.
var DefaultHostDependencyOrder = &HostDependencyOrder{
	Direction: OrderDirectionAsc,
	Field: &HostDependencyOrderField{
		field: hostdependency.FieldID,
		toCursor: func(hd *HostDependency) Cursor {
			return Cursor{ID: hd.ID}
		},
	},
}

// ToEdge converts HostDependency into HostDependencyEdge.
func (hd *HostDependency) ToEdge(order *HostDependencyOrder) *HostDependencyEdge {
	if order == nil {
		order = DefaultHostDependencyOrder
	}
	return &HostDependencyEdge{
		Node:   hd,
		Cursor: order.Field.toCursor(hd),
	}
}

// IdentityEdge is the edge representation of Identity.
type IdentityEdge struct {
	Node   *Identity `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// IdentityConnection is the connection containing edges to Identity.
type IdentityConnection struct {
	Edges      []*IdentityEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// IdentityPaginateOption enables pagination customization.
type IdentityPaginateOption func(*identityPager) error

// WithIdentityOrder configures pagination ordering.
func WithIdentityOrder(order *IdentityOrder) IdentityPaginateOption {
	if order == nil {
		order = DefaultIdentityOrder
	}
	o := *order
	return func(pager *identityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIdentityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIdentityFilter configures pagination filter.
func WithIdentityFilter(filter func(*IdentityQuery) (*IdentityQuery, error)) IdentityPaginateOption {
	return func(pager *identityPager) error {
		if filter == nil {
			return errors.New("IdentityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type identityPager struct {
	order  *IdentityOrder
	filter func(*IdentityQuery) (*IdentityQuery, error)
}

func newIdentityPager(opts []IdentityPaginateOption) (*identityPager, error) {
	pager := &identityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIdentityOrder
	}
	return pager, nil
}

func (p *identityPager) applyFilter(query *IdentityQuery) (*IdentityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *identityPager) toCursor(i *Identity) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *identityPager) applyCursors(query *IdentityQuery, after, before *Cursor) *IdentityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultIdentityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *identityPager) applyOrder(query *IdentityQuery, reverse bool) *IdentityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultIdentityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultIdentityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Identity.
func (i *IdentityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IdentityPaginateOption,
) (*IdentityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIdentityPager(opts)
	if err != nil {
		return nil, err
	}

	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}

	conn := &IdentityConnection{Edges: []*IdentityEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := i.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := i.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	i = pager.applyCursors(i, after, before)
	i = pager.applyOrder(i, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		i = i.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		i = i.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := i.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Identity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Identity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Identity {
			return nodes[i]
		}
	}

	conn.Edges = make([]*IdentityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &IdentityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// IdentityOrderField defines the ordering field of Identity.
type IdentityOrderField struct {
	field    string
	toCursor func(*Identity) Cursor
}

// IdentityOrder defines the ordering of Identity.
type IdentityOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *IdentityOrderField `json:"field"`
}

// DefaultIdentityOrder is the default ordering of Identity.
var DefaultIdentityOrder = &IdentityOrder{
	Direction: OrderDirectionAsc,
	Field: &IdentityOrderField{
		field: identity.FieldID,
		toCursor: func(i *Identity) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Identity into IdentityEdge.
func (i *Identity) ToEdge(order *IdentityOrder) *IdentityEdge {
	if order == nil {
		order = DefaultIdentityOrder
	}
	return &IdentityEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// IncludedNetworkEdge is the edge representation of IncludedNetwork.
type IncludedNetworkEdge struct {
	Node   *IncludedNetwork `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// IncludedNetworkConnection is the connection containing edges to IncludedNetwork.
type IncludedNetworkConnection struct {
	Edges      []*IncludedNetworkEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// IncludedNetworkPaginateOption enables pagination customization.
type IncludedNetworkPaginateOption func(*includedNetworkPager) error

// WithIncludedNetworkOrder configures pagination ordering.
func WithIncludedNetworkOrder(order *IncludedNetworkOrder) IncludedNetworkPaginateOption {
	if order == nil {
		order = DefaultIncludedNetworkOrder
	}
	o := *order
	return func(pager *includedNetworkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIncludedNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIncludedNetworkFilter configures pagination filter.
func WithIncludedNetworkFilter(filter func(*IncludedNetworkQuery) (*IncludedNetworkQuery, error)) IncludedNetworkPaginateOption {
	return func(pager *includedNetworkPager) error {
		if filter == nil {
			return errors.New("IncludedNetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type includedNetworkPager struct {
	order  *IncludedNetworkOrder
	filter func(*IncludedNetworkQuery) (*IncludedNetworkQuery, error)
}

func newIncludedNetworkPager(opts []IncludedNetworkPaginateOption) (*includedNetworkPager, error) {
	pager := &includedNetworkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIncludedNetworkOrder
	}
	return pager, nil
}

func (p *includedNetworkPager) applyFilter(query *IncludedNetworkQuery) (*IncludedNetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *includedNetworkPager) toCursor(in *IncludedNetwork) Cursor {
	return p.order.Field.toCursor(in)
}

func (p *includedNetworkPager) applyCursors(query *IncludedNetworkQuery, after, before *Cursor) *IncludedNetworkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultIncludedNetworkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *includedNetworkPager) applyOrder(query *IncludedNetworkQuery, reverse bool) *IncludedNetworkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultIncludedNetworkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultIncludedNetworkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to IncludedNetwork.
func (in *IncludedNetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IncludedNetworkPaginateOption,
) (*IncludedNetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIncludedNetworkPager(opts)
	if err != nil {
		return nil, err
	}

	if in, err = pager.applyFilter(in); err != nil {
		return nil, err
	}

	conn := &IncludedNetworkConnection{Edges: []*IncludedNetworkEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := in.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := in.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	in = pager.applyCursors(in, after, before)
	in = pager.applyOrder(in, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		in = in.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		in = in.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := in.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *IncludedNetwork
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IncludedNetwork {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IncludedNetwork {
			return nodes[i]
		}
	}

	conn.Edges = make([]*IncludedNetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &IncludedNetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// IncludedNetworkOrderField defines the ordering field of IncludedNetwork.
type IncludedNetworkOrderField struct {
	field    string
	toCursor func(*IncludedNetwork) Cursor
}

// IncludedNetworkOrder defines the ordering of IncludedNetwork.
type IncludedNetworkOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *IncludedNetworkOrderField `json:"field"`
}

// DefaultIncludedNetworkOrder is the default ordering of IncludedNetwork.
var DefaultIncludedNetworkOrder = &IncludedNetworkOrder{
	Direction: OrderDirectionAsc,
	Field: &IncludedNetworkOrderField{
		field: includednetwork.FieldID,
		toCursor: func(in *IncludedNetwork) Cursor {
			return Cursor{ID: in.ID}
		},
	},
}

// ToEdge converts IncludedNetwork into IncludedNetworkEdge.
func (in *IncludedNetwork) ToEdge(order *IncludedNetworkOrder) *IncludedNetworkEdge {
	if order == nil {
		order = DefaultIncludedNetworkOrder
	}
	return &IncludedNetworkEdge{
		Node:   in,
		Cursor: order.Field.toCursor(in),
	}
}

// NetworkEdge is the edge representation of Network.
type NetworkEdge struct {
	Node   *Network `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// NetworkConnection is the connection containing edges to Network.
type NetworkConnection struct {
	Edges      []*NetworkEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// NetworkPaginateOption enables pagination customization.
type NetworkPaginateOption func(*networkPager) error

// WithNetworkOrder configures pagination ordering.
func WithNetworkOrder(order *NetworkOrder) NetworkPaginateOption {
	if order == nil {
		order = DefaultNetworkOrder
	}
	o := *order
	return func(pager *networkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNetworkFilter configures pagination filter.
func WithNetworkFilter(filter func(*NetworkQuery) (*NetworkQuery, error)) NetworkPaginateOption {
	return func(pager *networkPager) error {
		if filter == nil {
			return errors.New("NetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type networkPager struct {
	order  *NetworkOrder
	filter func(*NetworkQuery) (*NetworkQuery, error)
}

func newNetworkPager(opts []NetworkPaginateOption) (*networkPager, error) {
	pager := &networkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNetworkOrder
	}
	return pager, nil
}

func (p *networkPager) applyFilter(query *NetworkQuery) (*NetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *networkPager) toCursor(n *Network) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *networkPager) applyCursors(query *NetworkQuery, after, before *Cursor) *NetworkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultNetworkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *networkPager) applyOrder(query *NetworkQuery, reverse bool) *NetworkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultNetworkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultNetworkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Network.
func (n *NetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NetworkPaginateOption,
) (*NetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNetworkPager(opts)
	if err != nil {
		return nil, err
	}

	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}

	conn := &NetworkConnection{Edges: []*NetworkEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := n.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := n.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	n = pager.applyCursors(n, after, before)
	n = pager.applyOrder(n, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		n = n.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		n = n.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := n.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Network
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Network {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Network {
			return nodes[i]
		}
	}

	conn.Edges = make([]*NetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &NetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// NetworkOrderField defines the ordering field of Network.
type NetworkOrderField struct {
	field    string
	toCursor func(*Network) Cursor
}

// NetworkOrder defines the ordering of Network.
type NetworkOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *NetworkOrderField `json:"field"`
}

// DefaultNetworkOrder is the default ordering of Network.
var DefaultNetworkOrder = &NetworkOrder{
	Direction: OrderDirectionAsc,
	Field: &NetworkOrderField{
		field: network.FieldID,
		toCursor: func(n *Network) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Network into NetworkEdge.
func (n *Network) ToEdge(order *NetworkOrder) *NetworkEdge {
	if order == nil {
		order = DefaultNetworkOrder
	}
	return &NetworkEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// PlanEdge is the edge representation of Plan.
type PlanEdge struct {
	Node   *Plan  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// PlanConnection is the connection containing edges to Plan.
type PlanConnection struct {
	Edges      []*PlanEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// PlanPaginateOption enables pagination customization.
type PlanPaginateOption func(*planPager) error

// WithPlanOrder configures pagination ordering.
func WithPlanOrder(order *PlanOrder) PlanPaginateOption {
	if order == nil {
		order = DefaultPlanOrder
	}
	o := *order
	return func(pager *planPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlanFilter configures pagination filter.
func WithPlanFilter(filter func(*PlanQuery) (*PlanQuery, error)) PlanPaginateOption {
	return func(pager *planPager) error {
		if filter == nil {
			return errors.New("PlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type planPager struct {
	order  *PlanOrder
	filter func(*PlanQuery) (*PlanQuery, error)
}

func newPlanPager(opts []PlanPaginateOption) (*planPager, error) {
	pager := &planPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlanOrder
	}
	return pager, nil
}

func (p *planPager) applyFilter(query *PlanQuery) (*PlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *planPager) toCursor(pl *Plan) Cursor {
	return p.order.Field.toCursor(pl)
}

func (p *planPager) applyCursors(query *PlanQuery, after, before *Cursor) *PlanQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlanOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *planPager) applyOrder(query *PlanQuery, reverse bool) *PlanQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlanOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlanOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Plan.
func (pl *PlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlanPaginateOption,
) (*PlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlanPager(opts)
	if err != nil {
		return nil, err
	}

	if pl, err = pager.applyFilter(pl); err != nil {
		return nil, err
	}

	conn := &PlanConnection{Edges: []*PlanEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pl = pager.applyCursors(pl, after, before)
	pl = pager.applyOrder(pl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pl = pl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pl = pl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Plan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Plan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Plan {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// PlanOrderField defines the ordering field of Plan.
type PlanOrderField struct {
	field    string
	toCursor func(*Plan) Cursor
}

// PlanOrder defines the ordering of Plan.
type PlanOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *PlanOrderField `json:"field"`
}

// DefaultPlanOrder is the default ordering of Plan.
var DefaultPlanOrder = &PlanOrder{
	Direction: OrderDirectionAsc,
	Field: &PlanOrderField{
		field: plan.FieldID,
		toCursor: func(pl *Plan) Cursor {
			return Cursor{ID: pl.ID}
		},
	},
}

// ToEdge converts Plan into PlanEdge.
func (pl *Plan) ToEdge(order *PlanOrder) *PlanEdge {
	if order == nil {
		order = DefaultPlanOrder
	}
	return &PlanEdge{
		Node:   pl,
		Cursor: order.Field.toCursor(pl),
	}
}

// PlanDiffEdge is the edge representation of PlanDiff.
type PlanDiffEdge struct {
	Node   *PlanDiff `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// PlanDiffConnection is the connection containing edges to PlanDiff.
type PlanDiffConnection struct {
	Edges      []*PlanDiffEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// PlanDiffPaginateOption enables pagination customization.
type PlanDiffPaginateOption func(*planDiffPager) error

// WithPlanDiffOrder configures pagination ordering.
func WithPlanDiffOrder(order *PlanDiffOrder) PlanDiffPaginateOption {
	if order == nil {
		order = DefaultPlanDiffOrder
	}
	o := *order
	return func(pager *planDiffPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlanDiffOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlanDiffFilter configures pagination filter.
func WithPlanDiffFilter(filter func(*PlanDiffQuery) (*PlanDiffQuery, error)) PlanDiffPaginateOption {
	return func(pager *planDiffPager) error {
		if filter == nil {
			return errors.New("PlanDiffQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type planDiffPager struct {
	order  *PlanDiffOrder
	filter func(*PlanDiffQuery) (*PlanDiffQuery, error)
}

func newPlanDiffPager(opts []PlanDiffPaginateOption) (*planDiffPager, error) {
	pager := &planDiffPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlanDiffOrder
	}
	return pager, nil
}

func (p *planDiffPager) applyFilter(query *PlanDiffQuery) (*PlanDiffQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *planDiffPager) toCursor(pd *PlanDiff) Cursor {
	return p.order.Field.toCursor(pd)
}

func (p *planDiffPager) applyCursors(query *PlanDiffQuery, after, before *Cursor) *PlanDiffQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlanDiffOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *planDiffPager) applyOrder(query *PlanDiffQuery, reverse bool) *PlanDiffQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlanDiffOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlanDiffOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to PlanDiff.
func (pd *PlanDiffQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlanDiffPaginateOption,
) (*PlanDiffConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlanDiffPager(opts)
	if err != nil {
		return nil, err
	}

	if pd, err = pager.applyFilter(pd); err != nil {
		return nil, err
	}

	conn := &PlanDiffConnection{Edges: []*PlanDiffEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pd = pager.applyCursors(pd, after, before)
	pd = pager.applyOrder(pd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pd = pd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pd = pd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *PlanDiff
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlanDiff {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlanDiff {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PlanDiffEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PlanDiffEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// PlanDiffOrderField defines the ordering field of PlanDiff.
type PlanDiffOrderField struct {
	field    string
	toCursor func(*PlanDiff) Cursor
}

// PlanDiffOrder defines the ordering of PlanDiff.
type PlanDiffOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *PlanDiffOrderField `json:"field"`
}

// DefaultPlanDiffOrder is the default ordering of PlanDiff.
var DefaultPlanDiffOrder = &PlanDiffOrder{
	Direction: OrderDirectionAsc,
	Field: &PlanDiffOrderField{
		field: plandiff.FieldID,
		toCursor: func(pd *PlanDiff) Cursor {
			return Cursor{ID: pd.ID}
		},
	},
}

// ToEdge converts PlanDiff into PlanDiffEdge.
func (pd *PlanDiff) ToEdge(order *PlanDiffOrder) *PlanDiffEdge {
	if order == nil {
		order = DefaultPlanDiffOrder
	}
	return &PlanDiffEdge{
		Node:   pd,
		Cursor: order.Field.toCursor(pd),
	}
}

// ProvisionedHostEdge is the edge representation of ProvisionedHost.
type ProvisionedHostEdge struct {
	Node   *ProvisionedHost `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ProvisionedHostConnection is the connection containing edges to ProvisionedHost.
type ProvisionedHostConnection struct {
	Edges      []*ProvisionedHostEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// ProvisionedHostPaginateOption enables pagination customization.
type ProvisionedHostPaginateOption func(*provisionedHostPager) error

// WithProvisionedHostOrder configures pagination ordering.
func WithProvisionedHostOrder(order *ProvisionedHostOrder) ProvisionedHostPaginateOption {
	if order == nil {
		order = DefaultProvisionedHostOrder
	}
	o := *order
	return func(pager *provisionedHostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisionedHostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisionedHostFilter configures pagination filter.
func WithProvisionedHostFilter(filter func(*ProvisionedHostQuery) (*ProvisionedHostQuery, error)) ProvisionedHostPaginateOption {
	return func(pager *provisionedHostPager) error {
		if filter == nil {
			return errors.New("ProvisionedHostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisionedHostPager struct {
	order  *ProvisionedHostOrder
	filter func(*ProvisionedHostQuery) (*ProvisionedHostQuery, error)
}

func newProvisionedHostPager(opts []ProvisionedHostPaginateOption) (*provisionedHostPager, error) {
	pager := &provisionedHostPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisionedHostOrder
	}
	return pager, nil
}

func (p *provisionedHostPager) applyFilter(query *ProvisionedHostQuery) (*ProvisionedHostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisionedHostPager) toCursor(ph *ProvisionedHost) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *provisionedHostPager) applyCursors(query *ProvisionedHostQuery, after, before *Cursor) *ProvisionedHostQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProvisionedHostOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *provisionedHostPager) applyOrder(query *ProvisionedHostQuery, reverse bool) *ProvisionedHostQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProvisionedHostOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProvisionedHostOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProvisionedHost.
func (ph *ProvisionedHostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisionedHostPaginateOption,
) (*ProvisionedHostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisionedHostPager(opts)
	if err != nil {
		return nil, err
	}

	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}

	conn := &ProvisionedHostConnection{Edges: []*ProvisionedHostEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ph.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ph.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ph = pager.applyCursors(ph, after, before)
	ph = pager.applyOrder(ph, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ph = ph.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ph = ph.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ph.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProvisionedHost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisionedHost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisionedHost {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProvisionedHostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProvisionedHostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProvisionedHostOrderField defines the ordering field of ProvisionedHost.
type ProvisionedHostOrderField struct {
	field    string
	toCursor func(*ProvisionedHost) Cursor
}

// ProvisionedHostOrder defines the ordering of ProvisionedHost.
type ProvisionedHostOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ProvisionedHostOrderField `json:"field"`
}

// DefaultProvisionedHostOrder is the default ordering of ProvisionedHost.
var DefaultProvisionedHostOrder = &ProvisionedHostOrder{
	Direction: OrderDirectionAsc,
	Field: &ProvisionedHostOrderField{
		field: provisionedhost.FieldID,
		toCursor: func(ph *ProvisionedHost) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts ProvisionedHost into ProvisionedHostEdge.
func (ph *ProvisionedHost) ToEdge(order *ProvisionedHostOrder) *ProvisionedHostEdge {
	if order == nil {
		order = DefaultProvisionedHostOrder
	}
	return &ProvisionedHostEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProvisionedNetworkEdge is the edge representation of ProvisionedNetwork.
type ProvisionedNetworkEdge struct {
	Node   *ProvisionedNetwork `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// ProvisionedNetworkConnection is the connection containing edges to ProvisionedNetwork.
type ProvisionedNetworkConnection struct {
	Edges      []*ProvisionedNetworkEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

// ProvisionedNetworkPaginateOption enables pagination customization.
type ProvisionedNetworkPaginateOption func(*provisionedNetworkPager) error

// WithProvisionedNetworkOrder configures pagination ordering.
func WithProvisionedNetworkOrder(order *ProvisionedNetworkOrder) ProvisionedNetworkPaginateOption {
	if order == nil {
		order = DefaultProvisionedNetworkOrder
	}
	o := *order
	return func(pager *provisionedNetworkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisionedNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisionedNetworkFilter configures pagination filter.
func WithProvisionedNetworkFilter(filter func(*ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error)) ProvisionedNetworkPaginateOption {
	return func(pager *provisionedNetworkPager) error {
		if filter == nil {
			return errors.New("ProvisionedNetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisionedNetworkPager struct {
	order  *ProvisionedNetworkOrder
	filter func(*ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error)
}

func newProvisionedNetworkPager(opts []ProvisionedNetworkPaginateOption) (*provisionedNetworkPager, error) {
	pager := &provisionedNetworkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisionedNetworkOrder
	}
	return pager, nil
}

func (p *provisionedNetworkPager) applyFilter(query *ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisionedNetworkPager) toCursor(pn *ProvisionedNetwork) Cursor {
	return p.order.Field.toCursor(pn)
}

func (p *provisionedNetworkPager) applyCursors(query *ProvisionedNetworkQuery, after, before *Cursor) *ProvisionedNetworkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProvisionedNetworkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *provisionedNetworkPager) applyOrder(query *ProvisionedNetworkQuery, reverse bool) *ProvisionedNetworkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProvisionedNetworkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProvisionedNetworkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProvisionedNetwork.
func (pn *ProvisionedNetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisionedNetworkPaginateOption,
) (*ProvisionedNetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisionedNetworkPager(opts)
	if err != nil {
		return nil, err
	}

	if pn, err = pager.applyFilter(pn); err != nil {
		return nil, err
	}

	conn := &ProvisionedNetworkConnection{Edges: []*ProvisionedNetworkEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pn.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pn.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pn = pager.applyCursors(pn, after, before)
	pn = pager.applyOrder(pn, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pn = pn.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pn = pn.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pn.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProvisionedNetwork
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisionedNetwork {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisionedNetwork {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProvisionedNetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProvisionedNetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProvisionedNetworkOrderField defines the ordering field of ProvisionedNetwork.
type ProvisionedNetworkOrderField struct {
	field    string
	toCursor func(*ProvisionedNetwork) Cursor
}

// ProvisionedNetworkOrder defines the ordering of ProvisionedNetwork.
type ProvisionedNetworkOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *ProvisionedNetworkOrderField `json:"field"`
}

// DefaultProvisionedNetworkOrder is the default ordering of ProvisionedNetwork.
var DefaultProvisionedNetworkOrder = &ProvisionedNetworkOrder{
	Direction: OrderDirectionAsc,
	Field: &ProvisionedNetworkOrderField{
		field: provisionednetwork.FieldID,
		toCursor: func(pn *ProvisionedNetwork) Cursor {
			return Cursor{ID: pn.ID}
		},
	},
}

// ToEdge converts ProvisionedNetwork into ProvisionedNetworkEdge.
func (pn *ProvisionedNetwork) ToEdge(order *ProvisionedNetworkOrder) *ProvisionedNetworkEdge {
	if order == nil {
		order = DefaultProvisionedNetworkOrder
	}
	return &ProvisionedNetworkEdge{
		Node:   pn,
		Cursor: order.Field.toCursor(pn),
	}
}

// ProvisioningStepEdge is the edge representation of ProvisioningStep.
type ProvisioningStepEdge struct {
	Node   *ProvisioningStep `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProvisioningStepConnection is the connection containing edges to ProvisioningStep.
type ProvisioningStepConnection struct {
	Edges      []*ProvisioningStepEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// ProvisioningStepPaginateOption enables pagination customization.
type ProvisioningStepPaginateOption func(*provisioningStepPager) error

// WithProvisioningStepOrder configures pagination ordering.
func WithProvisioningStepOrder(order *ProvisioningStepOrder) ProvisioningStepPaginateOption {
	if order == nil {
		order = DefaultProvisioningStepOrder
	}
	o := *order
	return func(pager *provisioningStepPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisioningStepOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisioningStepFilter configures pagination filter.
func WithProvisioningStepFilter(filter func(*ProvisioningStepQuery) (*ProvisioningStepQuery, error)) ProvisioningStepPaginateOption {
	return func(pager *provisioningStepPager) error {
		if filter == nil {
			return errors.New("ProvisioningStepQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisioningStepPager struct {
	order  *ProvisioningStepOrder
	filter func(*ProvisioningStepQuery) (*ProvisioningStepQuery, error)
}

func newProvisioningStepPager(opts []ProvisioningStepPaginateOption) (*provisioningStepPager, error) {
	pager := &provisioningStepPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisioningStepOrder
	}
	return pager, nil
}

func (p *provisioningStepPager) applyFilter(query *ProvisioningStepQuery) (*ProvisioningStepQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisioningStepPager) toCursor(ps *ProvisioningStep) Cursor {
	return p.order.Field.toCursor(ps)
}

func (p *provisioningStepPager) applyCursors(query *ProvisioningStepQuery, after, before *Cursor) *ProvisioningStepQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProvisioningStepOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *provisioningStepPager) applyOrder(query *ProvisioningStepQuery, reverse bool) *ProvisioningStepQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProvisioningStepOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProvisioningStepOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProvisioningStep.
func (ps *ProvisioningStepQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisioningStepPaginateOption,
) (*ProvisioningStepConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisioningStepPager(opts)
	if err != nil {
		return nil, err
	}

	if ps, err = pager.applyFilter(ps); err != nil {
		return nil, err
	}

	conn := &ProvisioningStepConnection{Edges: []*ProvisioningStepEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ps.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ps.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ps = pager.applyCursors(ps, after, before)
	ps = pager.applyOrder(ps, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ps = ps.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ps = ps.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ps.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProvisioningStep
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisioningStep {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisioningStep {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProvisioningStepEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProvisioningStepEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProvisioningStepOrderField defines the ordering field of ProvisioningStep.
type ProvisioningStepOrderField struct {
	field    string
	toCursor func(*ProvisioningStep) Cursor
}

// ProvisioningStepOrder defines the ordering of ProvisioningStep.
type ProvisioningStepOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProvisioningStepOrderField `json:"field"`
}

// DefaultProvisioningStepOrder is the default ordering of ProvisioningStep.
var DefaultProvisioningStepOrder = &ProvisioningStepOrder{
	Direction: OrderDirectionAsc,
	Field: &ProvisioningStepOrderField{
		field: provisioningstep.FieldID,
		toCursor: func(ps *ProvisioningStep) Cursor {
			return Cursor{ID: ps.ID}
		},
	},
}

// ToEdge converts ProvisioningStep into ProvisioningStepEdge.
func (ps *ProvisioningStep) ToEdge(order *ProvisioningStepOrder) *ProvisioningStepEdge {
	if order == nil {
		order = DefaultProvisioningStepOrder
	}
	return &ProvisioningStepEdge{
		Node:   ps,
		Cursor: order.Field.toCursor(ps),
	}
}

// RepositoryEdge is the edge representation of Repository.
type RepositoryEdge struct {
	Node   *Repository `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// RepositoryConnection is the connection containing edges to Repository.
type RepositoryConnection struct {
	Edges      []*RepositoryEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// RepositoryPaginateOption enables pagination customization.
type RepositoryPaginateOption func(*repositoryPager) error

// WithRepositoryOrder configures pagination ordering.
func WithRepositoryOrder(order *RepositoryOrder) RepositoryPaginateOption {
	if order == nil {
		order = DefaultRepositoryOrder
	}
	o := *order
	return func(pager *repositoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRepositoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRepositoryFilter configures pagination filter.
func WithRepositoryFilter(filter func(*RepositoryQuery) (*RepositoryQuery, error)) RepositoryPaginateOption {
	return func(pager *repositoryPager) error {
		if filter == nil {
			return errors.New("RepositoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type repositoryPager struct {
	order  *RepositoryOrder
	filter func(*RepositoryQuery) (*RepositoryQuery, error)
}

func newRepositoryPager(opts []RepositoryPaginateOption) (*repositoryPager, error) {
	pager := &repositoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRepositoryOrder
	}
	return pager, nil
}

func (p *repositoryPager) applyFilter(query *RepositoryQuery) (*RepositoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *repositoryPager) toCursor(r *Repository) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *repositoryPager) applyCursors(query *RepositoryQuery, after, before *Cursor) *RepositoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRepositoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *repositoryPager) applyOrder(query *RepositoryQuery, reverse bool) *RepositoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRepositoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRepositoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Repository.
func (r *RepositoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RepositoryPaginateOption,
) (*RepositoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRepositoryPager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RepositoryConnection{Edges: []*RepositoryEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Repository
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Repository {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Repository {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RepositoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RepositoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// RepositoryOrderField defines the ordering field of Repository.
type RepositoryOrderField struct {
	field    string
	toCursor func(*Repository) Cursor
}

// RepositoryOrder defines the ordering of Repository.
type RepositoryOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *RepositoryOrderField `json:"field"`
}

// DefaultRepositoryOrder is the default ordering of Repository.
var DefaultRepositoryOrder = &RepositoryOrder{
	Direction: OrderDirectionAsc,
	Field: &RepositoryOrderField{
		field: repository.FieldID,
		toCursor: func(r *Repository) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Repository into RepositoryEdge.
func (r *Repository) ToEdge(order *RepositoryOrder) *RepositoryEdge {
	if order == nil {
		order = DefaultRepositoryOrder
	}
	return &RepositoryEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// ScriptEdge is the edge representation of Script.
type ScriptEdge struct {
	Node   *Script `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ScriptConnection is the connection containing edges to Script.
type ScriptConnection struct {
	Edges      []*ScriptEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// ScriptPaginateOption enables pagination customization.
type ScriptPaginateOption func(*scriptPager) error

// WithScriptOrder configures pagination ordering.
func WithScriptOrder(order *ScriptOrder) ScriptPaginateOption {
	if order == nil {
		order = DefaultScriptOrder
	}
	o := *order
	return func(pager *scriptPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScriptOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScriptFilter configures pagination filter.
func WithScriptFilter(filter func(*ScriptQuery) (*ScriptQuery, error)) ScriptPaginateOption {
	return func(pager *scriptPager) error {
		if filter == nil {
			return errors.New("ScriptQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scriptPager struct {
	order  *ScriptOrder
	filter func(*ScriptQuery) (*ScriptQuery, error)
}

func newScriptPager(opts []ScriptPaginateOption) (*scriptPager, error) {
	pager := &scriptPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScriptOrder
	}
	return pager, nil
}

func (p *scriptPager) applyFilter(query *ScriptQuery) (*ScriptQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scriptPager) toCursor(s *Script) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *scriptPager) applyCursors(query *ScriptQuery, after, before *Cursor) *ScriptQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultScriptOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *scriptPager) applyOrder(query *ScriptQuery, reverse bool) *ScriptQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultScriptOrder.Field {
		query = query.Order(direction.orderFunc(DefaultScriptOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Script.
func (s *ScriptQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScriptPaginateOption,
) (*ScriptConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScriptPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &ScriptConnection{Edges: []*ScriptEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Script
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Script {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Script {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ScriptEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ScriptEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ScriptOrderField defines the ordering field of Script.
type ScriptOrderField struct {
	field    string
	toCursor func(*Script) Cursor
}

// ScriptOrder defines the ordering of Script.
type ScriptOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ScriptOrderField `json:"field"`
}

// DefaultScriptOrder is the default ordering of Script.
var DefaultScriptOrder = &ScriptOrder{
	Direction: OrderDirectionAsc,
	Field: &ScriptOrderField{
		field: script.FieldID,
		toCursor: func(s *Script) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Script into ScriptEdge.
func (s *Script) ToEdge(order *ScriptOrder) *ScriptEdge {
	if order == nil {
		order = DefaultScriptOrder
	}
	return &ScriptEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// ServerTaskEdge is the edge representation of ServerTask.
type ServerTaskEdge struct {
	Node   *ServerTask `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ServerTaskConnection is the connection containing edges to ServerTask.
type ServerTaskConnection struct {
	Edges      []*ServerTaskEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// ServerTaskPaginateOption enables pagination customization.
type ServerTaskPaginateOption func(*serverTaskPager) error

// WithServerTaskOrder configures pagination ordering.
func WithServerTaskOrder(order *ServerTaskOrder) ServerTaskPaginateOption {
	if order == nil {
		order = DefaultServerTaskOrder
	}
	o := *order
	return func(pager *serverTaskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServerTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServerTaskFilter configures pagination filter.
func WithServerTaskFilter(filter func(*ServerTaskQuery) (*ServerTaskQuery, error)) ServerTaskPaginateOption {
	return func(pager *serverTaskPager) error {
		if filter == nil {
			return errors.New("ServerTaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serverTaskPager struct {
	order  *ServerTaskOrder
	filter func(*ServerTaskQuery) (*ServerTaskQuery, error)
}

func newServerTaskPager(opts []ServerTaskPaginateOption) (*serverTaskPager, error) {
	pager := &serverTaskPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServerTaskOrder
	}
	return pager, nil
}

func (p *serverTaskPager) applyFilter(query *ServerTaskQuery) (*ServerTaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serverTaskPager) toCursor(st *ServerTask) Cursor {
	return p.order.Field.toCursor(st)
}

func (p *serverTaskPager) applyCursors(query *ServerTaskQuery, after, before *Cursor) *ServerTaskQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultServerTaskOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *serverTaskPager) applyOrder(query *ServerTaskQuery, reverse bool) *ServerTaskQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultServerTaskOrder.Field {
		query = query.Order(direction.orderFunc(DefaultServerTaskOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ServerTask.
func (st *ServerTaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServerTaskPaginateOption,
) (*ServerTaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServerTaskPager(opts)
	if err != nil {
		return nil, err
	}

	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}

	conn := &ServerTaskConnection{Edges: []*ServerTaskEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := st.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := st.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	st = pager.applyCursors(st, after, before)
	st = pager.applyOrder(st, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		st = st.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		st = st.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := st.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ServerTask
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServerTask {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServerTask {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ServerTaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ServerTaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ServerTaskOrderField defines the ordering field of ServerTask.
type ServerTaskOrderField struct {
	field    string
	toCursor func(*ServerTask) Cursor
}

// ServerTaskOrder defines the ordering of ServerTask.
type ServerTaskOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ServerTaskOrderField `json:"field"`
}

// DefaultServerTaskOrder is the default ordering of ServerTask.
var DefaultServerTaskOrder = &ServerTaskOrder{
	Direction: OrderDirectionAsc,
	Field: &ServerTaskOrderField{
		field: servertask.FieldID,
		toCursor: func(st *ServerTask) Cursor {
			return Cursor{ID: st.ID}
		},
	},
}

// ToEdge converts ServerTask into ServerTaskEdge.
func (st *ServerTask) ToEdge(order *ServerTaskOrder) *ServerTaskEdge {
	if order == nil {
		order = DefaultServerTaskOrder
	}
	return &ServerTaskEdge{
		Node:   st,
		Cursor: order.Field.toCursor(st),
	}
}

// StatusEdge is the edge representation of Status.
type StatusEdge struct {
	Node   *Status `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// StatusConnection is the connection containing edges to Status.
type StatusConnection struct {
	Edges      []*StatusEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// StatusPaginateOption enables pagination customization.
type StatusPaginateOption func(*statusPager) error

// WithStatusOrder configures pagination ordering.
func WithStatusOrder(order *StatusOrder) StatusPaginateOption {
	if order == nil {
		order = DefaultStatusOrder
	}
	o := *order
	return func(pager *statusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStatusFilter configures pagination filter.
func WithStatusFilter(filter func(*StatusQuery) (*StatusQuery, error)) StatusPaginateOption {
	return func(pager *statusPager) error {
		if filter == nil {
			return errors.New("StatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statusPager struct {
	order  *StatusOrder
	filter func(*StatusQuery) (*StatusQuery, error)
}

func newStatusPager(opts []StatusPaginateOption) (*statusPager, error) {
	pager := &statusPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStatusOrder
	}
	return pager, nil
}

func (p *statusPager) applyFilter(query *StatusQuery) (*StatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statusPager) toCursor(s *Status) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *statusPager) applyCursors(query *StatusQuery, after, before *Cursor) *StatusQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultStatusOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *statusPager) applyOrder(query *StatusQuery, reverse bool) *StatusQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultStatusOrder.Field {
		query = query.Order(direction.orderFunc(DefaultStatusOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Status.
func (s *StatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatusPaginateOption,
) (*StatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatusPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &StatusConnection{Edges: []*StatusEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Status
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Status {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Status {
			return nodes[i]
		}
	}

	conn.Edges = make([]*StatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &StatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// StatusOrderField defines the ordering field of Status.
type StatusOrderField struct {
	field    string
	toCursor func(*Status) Cursor
}

// StatusOrder defines the ordering of Status.
type StatusOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *StatusOrderField `json:"field"`
}

// DefaultStatusOrder is the default ordering of Status.
var DefaultStatusOrder = &StatusOrder{
	Direction: OrderDirectionAsc,
	Field: &StatusOrderField{
		field: status.FieldID,
		toCursor: func(s *Status) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Status into StatusEdge.
func (s *Status) ToEdge(order *StatusOrder) *StatusEdge {
	if order == nil {
		order = DefaultStatusOrder
	}
	return &StatusEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TagEdge is the edge representation of Tag.
type TagEdge struct {
	Node   *Tag   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TagConnection is the connection containing edges to Tag.
type TagConnection struct {
	Edges      []*TagEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// TagPaginateOption enables pagination customization.
type TagPaginateOption func(*tagPager) error

// WithTagOrder configures pagination ordering.
func WithTagOrder(order *TagOrder) TagPaginateOption {
	if order == nil {
		order = DefaultTagOrder
	}
	o := *order
	return func(pager *tagPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTagOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTagFilter configures pagination filter.
func WithTagFilter(filter func(*TagQuery) (*TagQuery, error)) TagPaginateOption {
	return func(pager *tagPager) error {
		if filter == nil {
			return errors.New("TagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagPager struct {
	order  *TagOrder
	filter func(*TagQuery) (*TagQuery, error)
}

func newTagPager(opts []TagPaginateOption) (*tagPager, error) {
	pager := &tagPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTagOrder
	}
	return pager, nil
}

func (p *tagPager) applyFilter(query *TagQuery) (*TagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagPager) toCursor(t *Tag) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tagPager) applyCursors(query *TagQuery, after, before *Cursor) *TagQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTagOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *tagPager) applyOrder(query *TagQuery, reverse bool) *TagQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTagOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTagOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Tag.
func (t *TagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagPaginateOption,
) (*TagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TagConnection{Edges: []*TagEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Tag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tag {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// TagOrderField defines the ordering field of Tag.
type TagOrderField struct {
	field    string
	toCursor func(*Tag) Cursor
}

// TagOrder defines the ordering of Tag.
type TagOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *TagOrderField `json:"field"`
}

// DefaultTagOrder is the default ordering of Tag.
var DefaultTagOrder = &TagOrder{
	Direction: OrderDirectionAsc,
	Field: &TagOrderField{
		field: tag.FieldID,
		toCursor: func(t *Tag) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Tag into TagEdge.
func (t *Tag) ToEdge(order *TagOrder) *TagEdge {
	if order == nil {
		order = DefaultTagOrder
	}
	return &TagEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TeamEdge is the edge representation of Team.
type TeamEdge struct {
	Node   *Team  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TeamConnection is the connection containing edges to Team.
type TeamConnection struct {
	Edges      []*TeamEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// TeamPaginateOption enables pagination customization.
type TeamPaginateOption func(*teamPager) error

// WithTeamOrder configures pagination ordering.
func WithTeamOrder(order *TeamOrder) TeamPaginateOption {
	if order == nil {
		order = DefaultTeamOrder
	}
	o := *order
	return func(pager *teamPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTeamOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTeamFilter configures pagination filter.
func WithTeamFilter(filter func(*TeamQuery) (*TeamQuery, error)) TeamPaginateOption {
	return func(pager *teamPager) error {
		if filter == nil {
			return errors.New("TeamQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type teamPager struct {
	order  *TeamOrder
	filter func(*TeamQuery) (*TeamQuery, error)
}

func newTeamPager(opts []TeamPaginateOption) (*teamPager, error) {
	pager := &teamPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTeamOrder
	}
	return pager, nil
}

func (p *teamPager) applyFilter(query *TeamQuery) (*TeamQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *teamPager) toCursor(t *Team) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *teamPager) applyCursors(query *TeamQuery, after, before *Cursor) *TeamQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTeamOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *teamPager) applyOrder(query *TeamQuery, reverse bool) *TeamQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTeamOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTeamOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Team.
func (t *TeamQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TeamPaginateOption,
) (*TeamConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTeamPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TeamConnection{Edges: []*TeamEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Team
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Team {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Team {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TeamEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TeamEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// TeamOrderField defines the ordering field of Team.
type TeamOrderField struct {
	field    string
	toCursor func(*Team) Cursor
}

// TeamOrder defines the ordering of Team.
type TeamOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TeamOrderField `json:"field"`
}

// DefaultTeamOrder is the default ordering of Team.
var DefaultTeamOrder = &TeamOrder{
	Direction: OrderDirectionAsc,
	Field: &TeamOrderField{
		field: team.FieldID,
		toCursor: func(t *Team) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Team into TeamEdge.
func (t *Team) ToEdge(order *TeamOrder) *TeamEdge {
	if order == nil {
		order = DefaultTeamOrder
	}
	return &TeamEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TokenEdge is the edge representation of Token.
type TokenEdge struct {
	Node   *Token `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TokenConnection is the connection containing edges to Token.
type TokenConnection struct {
	Edges      []*TokenEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*tokenPager) error

// WithTokenOrder configures pagination ordering.
func WithTokenOrder(order *TokenOrder) TokenPaginateOption {
	if order == nil {
		order = DefaultTokenOrder
	}
	o := *order
	return func(pager *tokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTokenFilter configures pagination filter.
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(pager *tokenPager) error {
		if filter == nil {
			return errors.New("TokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tokenPager struct {
	order  *TokenOrder
	filter func(*TokenQuery) (*TokenQuery, error)
}

func newTokenPager(opts []TokenPaginateOption) (*tokenPager, error) {
	pager := &tokenPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *tokenPager) applyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tokenPager) toCursor(t *Token) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tokenPager) applyCursors(query *TokenQuery, after, before *Cursor) *TokenQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTokenOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *tokenPager) applyOrder(query *TokenQuery, reverse bool) *TokenQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTokenOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTokenOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Token.
func (t *TokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TokenPaginateOption,
) (*TokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTokenPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TokenConnection{Edges: []*TokenEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Token
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Token {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Token {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// TokenOrderField defines the ordering field of Token.
type TokenOrderField struct {
	field    string
	toCursor func(*Token) Cursor
}

// TokenOrder defines the ordering of Token.
type TokenOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TokenOrderField `json:"field"`
}

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = &TokenOrder{
	Direction: OrderDirectionAsc,
	Field: &TokenOrderField{
		field: token.FieldID,
		toCursor: func(t *Token) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Token into TokenEdge.
func (t *Token) ToEdge(order *TokenOrder) *TokenEdge {
	if order == nil {
		order = DefaultTokenOrder
	}
	return &TokenEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}

	conn := &UserConnection{Edges: []*UserEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := u.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := u.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		u = u.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		u = u.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := u.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
